# the interview exercise

There's one part of every interview that, even with people that enjoy the interview process, seems to be universally detested: the in-person exercise. It exists in many forms for many roles, but is weighted particularly heavily in creative and technical positions – for me, I've encountered them most often during interviews for UX/UI design roles, and [entire books](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850/ref=pd_sbs_14_t_0/133-6724537-0434357?_encoding=UTF8&pd_rd_i=0984782850&pd_rd_r=43cd4385-2767-4cd1-b9e6-d1510b8de82f&pd_rd_w=zLrr5&pd_rd_wg=25lMr&pf_rd_p=5cfcfe89-300f-47d2-b1ad-a4e27203a02a&pf_rd_r=WQ0EFQ8HR8AKTA8WKFBF&psc=1&refRID=WQ0EFQ8HR8AKTA8WKFBF) have been written about their ubiquity in programming interviews. For the former, I've had the (mis)fortune of being on both sides of the process, as one of the case study facilitators for Epic's UX Designer role.

There are two types of interview exercises: the first are those where the candidate is told "there's no right answer, we just want to understand how you think." The second, perhaps more insidious type is the one where there actually is a correct answer to the problem, where the entire question of how capable the candidate is for the job comes down to whether they happen to have in working memory a solution to some question of varying difficulty. But even for the exercises where there's supposedly "no right answer", I find that there often still is, implicitly, or there's a kind of narrow range of solutions that would be considered passing. This narrow range may be defined by role requirements, or may be just a function of what the person facilitating the interview cares most about on any given day.

No matter who you are, everyone's experience and history have led them to care about a set of things more intensely than other things they could care about. In the development interviews I've had, these things typically involve whether the candidate has immediate working knowledge of specific data structures and algorithms, which are kind of best-guess proxies for the things the dev hiring manager really cares about: can you ship production code, are you familiar with unit testing, do you know *X* language? You have a certain set of concerns that your career has led you to devote most of your mental energy to, and it's natural to want to look for other people who also care about those same things. You want to hire people who care about the things you care about, and so when you're asking questions or doing exercises, you're paying attention to the signs that say whether they do, even if the exercise/question is phrased in a way that could be interpreted more generally. This is unavoidable, and it's part of the reason why coding exercises and design exercises suck so bad for candidates, because part of their job involves making their best guess at what aspect of the problem they should focus on to impress the person giving the recommendation to the hiring manager.

You care about: Unit testing, business logic, scripting performance, code quality.
I care about: Clean HTML and CSS, accessibility, aesthetics, user experience.

In each case, code is the medium, it's the thing that we work with, it's ultimately what our job comes down to, but we're approaching it from different directions, paying attention to different aspects. Does that mean that I'm not a good fit for the team? Does it mean that it wouldn't be a good idea to hire me, because my background has led me to spend more of my own mental energy on a different set of problems? How do we navigate this situation in a way that lets us learn from each other, instead of judging or "testing" each other? As far as I can tell this is a solved problem, but not one that's widely accepted: the only way to tell whether a person is going to do well at any given company is to let them work there – give them a trial period, a small piece of functionality, a test project; come back together to discuss, evaluate, and review; pay them for their time; decide based on what you've seen.

Because at the end of the day, the person making that recommendation to their company's hiring manager has to decide, or at least has to consider, whether they care about existing knowledge of certain predefined skills, or whether they care about balance, rounding out, filling in the gaps. Nobody can know everything. You're (probably) not going to find a candidate that is both expert at all the things the company is already good at, and also at all the things it's not.

There are two types of people in any given company. If we think of the entire company as a brick wall, made up of all the people who work there, then your first type of person is like a brick. They are the primary material of the wall. They have well-defined boundaries. They know who they are and what their job is and they do it well. The second type of person is the mortar. These people are harder to define, because their strength is in filling in the gaps, binding everything together.

Bricks are, arguably, more important to the overall existence of the wall. It's possible to build one with just bricks, if that's all you have. But the problem is that such a structure will be fragile. You need the mortar to provide stability, to make sure that the system doesn't collapse entirely in the face of unpredictable external forces. And these unpredictable external forces will arise, eventually. It's just a question of when. And at the risk of pushing the metaphor too far, when this happens, you have two options: you can either add more bricks (and the Roman arch is a testament to the possibilities of self-supporting structural engineering, given the proper configuration), or you can find some mortar.

It's easier to hire bricks. I think it's incredibly rare that I come across a company that's actively looking to hire for roles that don't currently exist in some well-defined way. And how could they? The way that most hiring is budgeted for is by looking at the current workloads of the people who already work there, balancing that against all the work that could be done, and then opening up roles based on that work. You define what you need in relation to what you already have. If the front-end developers are in over their head and are in danger of falling behind, then we need to hire another front-end developer.

Rarely are companies hiring people in an exploratory fashion, actively asking themselves "What are we missing? What are we bad at? How can we fill in the gaps?"